import random
import tkinter as tk
from tkinter import messagebox

# ---- Config ----
ROWS = 10
COLS = 10
MINES = 12

CELL_SIZE = 32  # px


class Minesweeper:
    def __init__(self, root):
        self.root = root
        self.root.title("Minesweeper")

        self.topbar = tk.Frame(root)
        self.topbar.pack(fill="x")

        self.status_var = tk.StringVar()
        self.status_label = tk.Label(self.topbar, textvariable=self.status_var, anchor="w")
        self.status_label.pack(side="left", padx=8)

        self.restart_btn = tk.Button(self.topbar, text="Restart", command=self.restart)
        self.restart_btn.pack(side="right", padx=8, pady=6)

        self.board_frame = tk.Frame(root)
        self.board_frame.pack(padx=10, pady=10)

        self.buttons = [[None for _ in range(COLS)] for _ in range(ROWS)]

        for r in range(ROWS):
            for c in range(COLS):
                btn = tk.Button(
                    self.board_frame,
                    width=2,
                    height=1,
                    font=("Helvetica", 14),
                    relief="raised",
                )
                btn.grid(row=r, column=c, sticky="nsew")
                btn.bind("<Button-1>", lambda e, rr=r, cc=c: self.on_left_click(rr, cc))
                btn.bind("<Button-3>", lambda e, rr=r, cc=c: self.on_right_click(rr, cc))
                self.buttons[r][c] = btn

        for c in range(COLS):
            self.board_frame.grid_columnconfigure(c, weight=1)
        for r in range(ROWS):
            self.board_frame.grid_rowconfigure(r, weight=1)

        self.restart()

    def restart(self):
        self.game_over = False
        self.flags = 0
        self.revealed_count = 0

        # Internal boards
        self.mines = [[False for _ in range(COLS)] for _ in range(ROWS)]
        self.numbers = [[0 for _ in range(COLS)] for _ in range(ROWS)]
        self.revealed = [[False for _ in range(COLS)] for _ in range(ROWS)]
        self.flagged = [[False for _ in range(COLS)] for _ in range(ROWS)]

        # Reset UI
        for r in range(ROWS):
            for c in range(COLS):
                b = self.buttons[r][c]
                b.config(text="", state="normal", relief="raised", bg="SystemButtonFace")

        self.place_mines()
        self.compute_numbers()
        self.update_status()

    def update_status(self):
        remaining = MINES - self.flags
        self.status_var.set(f"Mines: {MINES} | Flags used: {self.flags} | Flags remaining: {remaining}")

    def place_mines(self):
        positions = [(r, c) for r in range(ROWS) for c in range(COLS)]
        random.shuffle(positions)
        for i in range(MINES):
            r, c = positions[i]
            self.mines[r][c] = True

    def compute_numbers(self):
        for r in range(ROWS):
            for c in range(COLS):
                if self.mines[r][c]:
                    self.numbers[r][c] = -1
                    continue
                count = 0
                for rr, cc in self.neighbors(r, c):
                    if self.mines[rr][cc]:
                        count += 1
                self.numbers[r][c] = count

    def neighbors(self, r, c):
        for dr in (-1, 0, 1):
            for dc in (-1, 0, 1):
                if dr == 0 and dc == 0:
                    continue
                rr, cc = r + dr, c + dc
                if 0 <= rr < ROWS and 0 <= cc < COLS:
                    yield rr, cc

    def on_right_click(self, r, c):
        if self.game_over or self.revealed[r][c]:
            return

        if self.flagged[r][c]:
            self.flagged[r][c] = False
            self.flags -= 1
            self.buttons[r][c].config(text="")
        else:
            # Optional: prevent placing more flags than mines
            if self.flags >= MINES:
                return
            self.flagged[r][c] = True
            self.flags += 1
            self.buttons[r][c].config(text="ðŸš©")

        self.update_status()
        self.check_win()

    def on_left_click(self, r, c):
        if self.game_over or self.flagged[r][c] or self.revealed[r][c]:
            return

        if self.mines[r][c]:
            self.lose(r, c)
            return

        self.reveal_cell(r, c)
        self.check_win()

    def reveal_cell(self, r, c):
        # Flood fill reveal for empty cells
        stack = [(r, c)]
        while stack:
            rr, cc = stack.pop()
            if self.revealed[rr][cc] or self.flagged[rr][cc]:
                continue
            if self.mines[rr][cc]:
                continue

            self.revealed[rr][cc] = True
            self.revealed_count += 1

            n = self.numbers[rr][cc]
            b = self.buttons[rr][cc]
            b.config(relief="sunken", bg="#ddd")

            if n > 0:
                b.config(text=str(n), fg="black")
            else:
                b.config(text="")
                for nr, nc in self.neighbors(rr, cc):
                    if not self.revealed[nr][nc] and not self.mines[nr][nc]:
                        stack.append((nr, nc))

    def lose(self, hit_r, hit_c):
        self.game_over = True
        # Reveal all mines
        for r in range(ROWS):
            for c in range(COLS):
                b = self.buttons[r][c]
                if self.mines[r][c]:
                    b.config(text="ðŸ’£", bg="#f7b2b2")
                b.config(state="disabled")
        self.buttons[hit_r][hit_c].config(bg="#ff6b6b")
        messagebox.showinfo("Game Over", "Boom! You hit a mine.")

    def check_win(self):
        # Win if all non-mine cells are revealed
        total_safe = ROWS * COLS - MINES
        if not self.game_over and self.revealed_count == total_safe:
            self.game_over = True
            for r in range(ROWS):
                for c in range(COLS):
                    self.buttons[r][c].config(state="disabled")
            messagebox.showinfo("You Win!", "Nice! You cleared all safe cells.")

if __name__ == "__main__":
    root = tk.Tk()
    app = Minesweeper(root)
    root.mainloop()
